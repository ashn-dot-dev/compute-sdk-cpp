#ifndef FASTLY_SECRET_STORE_H
#define FASTLY_SECRET_STORE_H

#include "sdk-sys.h"
#include <optional>
#include <string>
#include <string_view>

namespace fastly::secret_store {

class SecretStore;

/// A secret from a secret store.
///
/// A secret name has a maximum length of 255 bytes and must contain
/// only letters, numbers, dashes (-), underscores (_), and periods (.).
///
/// A secret value has a maximum length of 64 KiB.
class Secret {
  friend SecretStore;

public:
  /// Create a new "ecret" from the given memory. This is *not* the suggested
  /// way to create `Secret`s; instead, we suggest using `SecretStore::get`.
  /// This secret will *NOT* be shared with other sessions.
  ///
  /// This method can be used for data that should be secret, but is being
  /// obtained by some other means than the secret store. New "ecrets" created
  /// this way use plaintext/ only, and live in the session's memory unencrypted
  /// for much longer than secrets generated by `SecretStore::get`. They
  /// should thus only be used in situations in which an API requires a
  /// `Secret`, but you cannot (for whatever reason) use a `SecretStore` to
  /// store them. As the early note says, this `Secret` will be local to the
  /// current session, and will not be shared with other sessions of this
  /// service.
  Secret(std::string_view str)
      : s(fastly::sys::secret_store::m_static_secret_store_secret_from_bytes(
            static_cast<std::string>(str))) {};

  /// Read the plaintext contents of a secret into memory as a byte buffer.
  ///
  /// Once a secret is read into memory, a secret's contents can be repeatedly
  /// accessed cheaply.
  ///
  /// # Examples
  ///
  /// Check if `fastly::http::HeaderValue` matches the contents of a
  /// secret.
  ///
  /// ```cpp
  /// auto secret{secret_store.get("example").value()};
  /// auto header{request.get_header("example").value()};
  /// if (secret.plaintext() == header) {
  ///     std::cout << "you have guessed correctly!";
  /// }
  /// ```
  std::string plaintext();

private:
  rust::Box<fastly::sys::secret_store::Secret> s;
  Secret(rust::Box<fastly::sys::secret_store::Secret> secret)
      : s(std::move(secret)) {};
};

/// A Compute Secret Store.
///
/// A secret store name has a maximum length of 255 bytes and must
/// contain only letters, numbers, dashes (-), underscores (_), and
/// periods (.).
class SecretStore {
public:
  static SecretStore open(std::string_view name);

  /// Lookup a `Secret` by name in this secret store.
  ///
  /// Returns `std::optional<Secret>` if the secret is found, and `std::nullopt`
  /// if the secret was not found.
  std::optional<Secret> get(std::string_view key);

  /// Return true if the secret store contains a secret with the given

  /// name.
  bool contains(std::string_view key);

private:
  rust::Box<fastly::sys::secret_store::SecretStore> ss;
  SecretStore(rust::Box<fastly::sys::secret_store::SecretStore> s)
      : ss(std::move(s)) {};
};

} // namespace fastly::secret_store

namespace fastly {
using fastly::secret_store::SecretStore;
}

#endif
